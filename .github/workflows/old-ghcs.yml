name: Validate old ghcs

# See: https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#concurrency.
concurrency:
  group: ${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

# Note: This workflow file contains the required job "Validate old ghcs post job". We are using path
# filtering here to ignore PRs which only change documentation. This can cause a problem, see the
# workflow file "old-ghcs.skip.yml" for a description of the problem and the solution provided in
# that file.
on:
  push:
    paths-ignore:
      - "doc/**"
      - "**/README.md"
      - "CONTRIBUTING.md"
      - "changelog.d/**"
      # only top level for these, because various test packages have them too
      - "*/ChangeLog.md"
      - "*/changelog.md"
      - "release-notes/**"
    branches:
      - master
  pull_request:
    paths-ignore:
      - "doc/**"
      - "**/README.md"
      - "CONTRIBUTING.md"
      - "changelog.d/**"
      - "*/ChangeLog.md"
      - "*/changelog.md"
      - "release-notes/**"
  release:
    types:
      - created
  workflow_call:

env:
  # We choose a stable ghc version across all os's
  # which will be used to do the next release
  GHC_FOR_RELEASE: "9.4.8"
  COMMON_FLAGS: "-j 2 -v"

jobs:

  validate-old-ghcs:
    name: Validate old ghcs ${{ matrix.extra-ghc }}
    runs-on: ubuntu-latest

    strategy:
      matrix:
        extra-ghc:
          ["8.4.4", "8.2.2", "8.0.2"]
          ## GHC 7.10.3 does not install on ubuntu-22.04 with ghcup.
          ## Older GHCs are not supported by ghcup in the first place.
      fail-fast: false

    steps:
      - uses: actions/checkout@v4

      - name: Install prerequisites for old GHCs
        run: |
          sudo apt-get update
          sudo apt-get install libncurses5 libtinfo5

      - name: Install extra compiler
        run: ghcup install ghc ${{ matrix.extra-ghc }}

      - name: GHCup logs
        # Does anyone know why the explicit "always()" here and below?
        # By default steps always run.
        if: always()
        run: cat /usr/local/.ghcup/logs/*

      - name: Install primary compiler
        uses: haskell-actions/setup@v2
        id: setup-haskell
        with:
          ghc-version: ${{ env.GHC_FOR_RELEASE }}
          cabal-version: latest

      - name: GHC versions
        run: |
          ghc --version
          "ghc-${{ matrix.extra-ghc }}" --version

      # This will get us an outdated cache, because this workflow runs before
      # validate.yml can update it. As a result, we end up rebuilding the PR.
      # The only way to fix this is to move it back into validate.yml, because
      # we can't force this to run synchronously with steps in a different
      # workflow.
      - uses: actions/cache@v4
        with:
          path: |
            ${{ steps.setup-haskell.outputs.cabal-store }}
          key: ${{ runner.os }}-${{ env.GHC_FOR_RELEASE }}-${{ github.sha }}
          restore-keys: ${{ runner.os }}-${{ env.GHC_FOR_RELEASE }}-

      - name: Validate build
        run: sh validate.sh ${{ env.COMMON_FLAGS }} -s build

      - name: "Validate lib-suite-extras --extra-hc ghc-${{ matrix.extra-ghc }}"
        env:
          EXTRA_GHC: ghc-${{ matrix.extra-ghc }}
        run: sh validate.sh ${{ env.COMMON_FLAGS }} --lib-only -s lib-suite-extras --extra-hc "${{ env.EXTRA_GHC }}"

  # We use this job as a summary of the workflow
  # It will fail if any of the previous jobs does
  # This way we can use it exclusively in branch protection rules
  # and abstract away the concrete jobs of the workflow, including their names.
  # See also the "skip" workflows, which these must match.
  validate-old-ghcs-post-job:
    if: always()
    name: Validate old ghcs post job
    runs-on: ubuntu-latest
    # IMPORTANT! Any job added to the workflow should be added here too
    # (This one is true because of the abstraction described above, and the
    # corresponding branch protection rules. ++bsa)
    needs: [validate-old-ghcs]

    steps:
      - run: |
          echo "jobs info: ${{ toJSON(needs) }}"
      - if: contains(needs.*.result, 'failure') || contains(needs.*.result, 'cancelled')
        run: exit 1
